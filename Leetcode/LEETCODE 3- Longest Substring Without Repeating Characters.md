# LEETCODE 3 : Longest Substring Without Repeating Characters

题目要求找出给定的一个字符串中没有重复字符的最长子字符串，例如`abcabcbb`中的最长字串是`abc`长度为3。

我首先尝试使用之前股票价格题目的方法使用单次遍历寻找目标子字符串，但是在处理遇到重复字符时重新开始计数的问题时碰到了大麻烦，一度以为单次遍历无法解决问题。这个问题是这样的，以`dvadacbd`为例，当我遇到第二个`d`时，若想正确计算出最长无重复子字符串，则必须从开头的`v`开始计数，但是这样就必须额外使用一些数据变量存放某种可以让我们便于回望的变量。就这样我开始尝试使用动态规划。

### 动态规划
动态规划的两大必要属性是`最优子结构`和`子问题重叠`。首先我们关注子问题重叠，我们可以轻易地发现，假设长度为n的字符串中的最优解LSWRC已经确定，在长度为n+1的字符串中：
* 之前的LSWRC如果与新加入的一个字符组成新解那么`子问题重叠`成立；
* 如果新加上的字符与其他任意字符组合长度依然不超过LSWRC，`子问题重叠`成立；

需要注意的是，LSWRC可能不止一个，所以上述结论依然成立。接下来是重点`最优子结构`，我使用两个额外数据结构，一个与输入字符串等长的数组用来存放从前往后计算在当前位置为止的子字符串中的LSWRC，另一个长度为255（ASCII码等长）的字符串用于存放每种字符之前的出现位置，若在该字符串中从未出现，则设为-1。在之后的改进中发现第二个数组太蠢，占用空间和速度都不理想，转为使用hashtable存放重复字符的出现位置，并且随时更新。




