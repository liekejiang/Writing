## 1.3 
本节主要介绍了三种基本数据结构：栈，队列和背包。这其中栈和队列是重点。本笔记用于记录java实现栈和队列中每个功能需要注意的地方。实现的方式有两种，分别是节点类和数组。

#### 栈-节点类
###### 初始化
自定义构造函数可有可无，基本的变量有指向栈顶的节点`first`和表示栈大小的整形变量`N`。 为了实现迭代功能，需要继承`Iterable`，实现一个名为`iterator`的公开方法，其返回一个具有`hasNext`, `next`的继承`Iterator`的类，用于迭代输出。

除此之外，需要注意泛型的实现，使用`<Item>`关键字。

###### Push & Pop
在栈中，我们实现的大都是非静态类，也就是说必须先有实例才能调用。在`push`函数中，我们需要定义一个新的辅助节点引用变量，用于替代原`first`的功能，first指向一个新地址用于构建存放被push进栈的值的节点。 在这里需要注意，引用变量可能存在的别名情况，不同的别名可能修改是同一个值，然而我们可以改变别名指向的地址从而避免潜在的设计冲突。新的`first`存放了push进来的变量之后要指向辅助节点以完成链表的构建， 之后需要调整`N`的大小。

而`pop`需要考虑的就比较多，首先我们要考虑在栈为空的时候误调用的情况，我们可以抛出一个异常以警示用户, 比如下面的例子：
`if (isEmpty()) throw new NoSuchElementException("Stack underflow");`
`push`动作不用返回任何值，但是我们希望`pop`会返回被弹出的栈顶值，因此我们要设定`pop`实例函数为`Item`类型。 与`push`类似，我们同样需要一个辅助节点替代`first`，然后获得其节点值。之后`first`重定向为辅助节点的`next`指向的节点，并将复制节点置`null`以回收。最后调整`N`的大小并返回获得的节点值。
#### 栈-数组类
###### 初始化
数组类的栈实现要稍微麻烦一点，尤其体现在数组的大小调整上，我们需要一个新函数用于在`push`前和`pop`结束时根据需要调整数组的大小。这里的数组是泛型数组，定义格式有些许不同:`(Item[]) a = (Item[]) new Object[capacity]`。 在实例变量的选择上只是把节点替换为一个大小为2的泛型数组并添加一个指向首地址的标值变量`first`，其他与节点类的栈实现并无二恙。
###### Push & Pop
在`push`开始时，首先检查`N`的大小是否与数组的大小相等，若是则调用调整函数将数组大小翻倍并迁移过去。然后将push进来的新值依次存放进数组并调整`N`的值。`pop`也类似，先获取数组中`--N`位的值，并将数组改位置`null`，随后判断`N`的值是否触及调整阈值（一般是1/4）然后调用调整函数，最后返回获得的值即可。

#### 队列-节点类
######初始化
队列的特点是先进先出，那么谁是头谁是尾就是一个需要注意的问题，我们都知道节点具有指向`next`的引用，但是也只有一个`next`。从入队出队的特点考虑，我们一般认为节点从头指向尾，头部节点用`first`尾部节点用`last`指代。初始化的其他方面与栈一致。

###### Enqueue & Dequeue 
与入队直接相关的引用是`last`，我们要利用一个辅助节点存放`last`原本的数据，然后令`last`存放入队的新值并使辅助节点的`next`指向`last`即可。除此之外我们还需要注意特殊情况，那就是当队列原本为空时，`last`和`first`都指向同一个节点,需要一个条件判断，此时不会调用`next`指向新节点。最后调整`N`的值。

出队的时候会更简单一点，只需要把`first`指向`first.next`的引用即可，但是同样需要注意当出队后为0或者为负的情况。当出队后为0时，我们需要改变`last`因为其引用的对象已经不存在了，需要将其置`null`, 而出队后为负的情况需要在函数开头就做出检查以避免错误。最后返回出队的Item。

#### 队列-数组类
###### 初始化
数组类的实现同样需要`first`和`last`，同样需要一个长度为2的泛型数组和一个调整数组大小的函数。

###### Push & Pop
数组类的`push`和`pop`实现需要一点小技巧，为了实现我们的最优设计中的单个操作与数据结构大小无关的原则，我们要人为构建循环数组，当`first`标志位溢出数组大小时，将其置0，从头开始，这是数组实现方法的核心思想。

在`push`开始时，首先检查`N`的大小是否与数组的大小相等，若是则调用调整函数将数组大小翻倍并迁移过去。然后将新值放置于`last`的位置并将`last`加1。若`last`超出了数组边界，将其置0从头开始，同时调整`N`的大小。

`pop`也是一致的，获取`first`位置的值并将其置`null`，然后`first`指向下一位，调整`N`的大小。如果`N`小于数组大小的1/4，则将整个数组迁移到1/2大小的新数组上。