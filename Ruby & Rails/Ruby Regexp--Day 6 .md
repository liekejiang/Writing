# Ruby Regexp--Day 5

Regexp 是 regulization express 的简写，用于将模式与字符串匹配。Ruby中，一个模式写在正斜杠字符中间，描述一个字符串的内容。初次之外，ruby也允许使用以%r为开头的表达式，后面跟着任意分隔符（这里任意是几乎任何两个成对的符号即可，加减乘除括号逗号冒号等等,但是分隔符内不能包括已被使用的分隔符作为匹配内容），在描述大量不想转义的斜杠字符时很有用。
语法格式：
```ruby
/regexp/
%r!/usr/local! #使用分隔符的正则表达式，还不懂具体语法

%r|/| 
```
## 常用分隔符
先介绍ruby中的常用分隔符：
* **;** : 分号用来分隔一行中的多个字符。
* **()** ： 提高优先级 或者 定义方法时容纳参数列表
* **空格** ： 分隔字符 或者 在可省略**()**的时候，代替**()**
* **,** : 隔开多个参数
* **.** ： 将对象与它的方法隔开
* **::** ： 域作用符，将模块与其常量分开

## =~ and #match operator
**~=** 和 **#match** 操作符可以实现模式匹配。 前者是基本的匹配模式，如果找到相匹配的字符串，则返回要匹配的字符串首字符在相应字符串中的下标。
```ruby
2.4.0 :002 > /love/ =~ "I love u"   => 2 
                        01234567
```

**#match** 会返回匹配数据对象，否则返回**nil**
```ruby
2.4.0 :003 > /love/.match  "I love u"                                                   => #<MatchData "love"> 
```
返回的是什么格式呢？

## 元字符和转义
元字符在模式中有具体特定含义。要匹配一个字符串，它们将被转回("\")或者转义。元字符有(,) (.) (?) (+) (-) (*) [,] {,}。否则返回匹配的字符串。这些字符也被称为控制字符
```ruby
2.4.0 :007 > /2 \* 2 \+ 3 \- 1 = \?/.match('Does 2 * 2 + 3 - 1 = ?')
 => #<MatchData "2 * 2 + 3 - 1 = ?"> 
 
2.4.0 :009 > /2 * 2 + 3 - 1 = ?/.match('Does 2 * 2 + 3 - 1 = ?')
 => nil 
```
简而言之，这些符号在正则表达式里另有他用，直接输入会产生歧义，所以为了正确地表达我们需要的意思，我们需要在前面加上“\”符号。上述代码范例给出了加与不加转义的区别。

## 字符类
有些特殊符号匹配需要转回或者转义，有些字母也需要。字符类使用方括号。
### [ab]

[ab]表示**a**或**b**，而/ab/表示**a**和**b**。
```ruby
2.4.0 :010 > /j[afdvs]av/.match('java')
 => nil 
2.4.0 :011 > /j[afdvs]va/.match('java')
 => #<MatchData "java"> 
```
上述代码可以看出，在第二次匹配时，a在这么多选项中被匹配上。
### [a-d]
这里[a-d]表示[abcd]。连字符(**-**)字符类表示字符的范围。
```ruby
2.4.0 :016 > /[a-ge-p]/.match('bf')
 => #<MatchData "b"> 
```
我们可以发现，会返回匹配到的第一个字符。
### [^a-d]
**^** 符号表示范围中不存在的其他任何字符。
```ruby
/[^a-d]/.match('abcdefghijklmnopq')
 => #<MatchData "e"> 
```
同样只会返回匹配到的第一个字符。

## 重复
本节定义的字符与单个字符匹配。在重复元字符的帮助下，可以指定需要发生的次数。 这些元字符称为量词。
* **\***：零次或多次
* **+**：一次或多次
* **?**: 零次或一次（可选）
* \* : 零次或多次
* **{n}**: 正好**n**次
* **{n,}**: **n**次以上
* **{，m}**: **m**次以下
* **{n,m}**: **n**到**m**次之间

```ruby
2.4.0 :028 > "SSSITT".match(/S{3}+[[:upper:]]+[[:upper:]]+[[:upper:]]/)
 => #<MatchData "SSSITT"> 
```
这句话表达的意思是，S要出现3次，+代表连接，[[:upper:]]代表任何大写字母（猜测）。这段代码也等同：
```ruby
2.4.0 :029 > "SSSITT".match(/S{3}+[[:upper:]]{3}/)
 => #<MatchData "SSSITT"> 
```
正则表达式和匹配字符串的先后在ruby中不重要。
## 分组
分组使用括号将项目组合在一起，将这些术语分组成一个。
```ruby
irb(main):001:0> /[aeiou]\w{2}/.match('family')
=> #<MatchData "ami">
irb(main):003:0> /([aeiou]\w){2}/.match('family')
=> #<MatchData "amil" 1:"il">
```
与其说是组合，不如说是优先级。这里\w代表任何一个数字，字母，下划线，汉字。

## 修饰符
本节主要介绍正则表达式中的各种修饰符。修饰符跟在/exp/modifiers 后面, 一次可使用多种修饰符。
* i : 当匹配文本时忽略大小写。
* o : 只执行一次#{}插值，regexp在第一次就执行判断。
* x : 忽略空格，允许在整个表达式中放入空白符和注释。
* m : 匹配多行，把换行符当作正常字符
* u,e,s,n : 把regexp解释为Unicode（UTF-8），EUC，SJIS，或者ASCII。默认源编码

元字符修饰符
* ^ : 以XXX开始，放在匹配串开头, 匹配成功则返回0或者match，否则返回nil。若是如下
结构/[^a-d]/, 那么会返回遇到的第一个不属于目标范围的index。
* $ : 以XXX结尾，放在匹配串末尾，成功返回匹配串在目标中的首尾index
* \A : 以字符开始，~~试了很多种，都返回0，没搞懂~~。\A其实会匹配字符串/行的开始，相当于一个标志位，其后跟随的是目标的第一个字符，组合使用，匹配必须是连续的。
* \z : 以字符结束,试了很多种，都返回字符串末尾indxe，没搞懂
* . : 任何字符
* \s ：任何空白字符
* \S ：任何非空白字符
* \d ：任何数字
* \D ：任何非数字
* \w ：任何单词（包括字母，数字，下划线）
* \W ： 任何非单词
* \b ：匹配一个单词边界，也就是指单词和空格间的位置，例如never中的er，但不是verb中的er。
* (a|b) :
* 

## %的用法
* %Q : 用于替代双引号的字符串，当需要在字符串内放入很多引号，可以使用 %Q(string), 或者其他成对的符号，如 ! !, < >, { }等等。 也可省略Q写作： %/I love u/。
* %q ：表示单引号字符串，其他如%Q一致。
* %W ：用于表示其中元素被双引号括起的数组, \ ,这样的斜杠空格会被转化成空格。
* %w ：用于表示元素被单引号括起的数组。
* %x : 与shell脚本有关。
* %r : regexp的另一种表达方式，与%Q相似。
* %s ：用于表示符号symbol，与%Q相似
* %i ：用于生成symbol数组。
* 

## 常用正则表达式
##### 用户名必须是：字母、数字、下划线和汉字      

```ruby
USER_NAME = /^[a-z0-9\w_\p{Han}]*$/i
```
* 以^开头，后面紧跟[]表示用户名的第一个字母必须是字母、数字、下划线、或者汉字
* [a-z0-9\w ]表示小写字母,数字和任意单词（字母数字下划线），感觉前面的都可以被\w代替。
* \p{Han} 表示支持汉字？
* \* 表示0次或多次? 为什么不用+， 明明一次或者多次更好。更正\*也可以表示一个
* $ 表示同样以字母、数字、下划线和汉字结尾
* i放在regexp的外面，表示忽略大小写
```ruby
%% **思考** :下面的是不是更简洁?
USER_NAME = /^[\w]+$/i
 ```
##### 密码必须是：字母、数字和下划线
```ruby
USER_PASSWORD = /^[a-z0-9\w_]*$/i
```
只是好奇为什么不用更简单的方法。

##### 合法的邮箱格式
```ruby
 USER_EMAIL = /\A\s*([-a-z0-9+._]{1,64})@((?:[-a-z0-9]+\.)+[a-z]{2,})\s*\z/i
```
* \A 表示以字符开始 \s* 表示任何数量的空白字符, 合起来表示匹配任意数量的空白字符
* 




